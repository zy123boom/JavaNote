## Java高级知识

#### 1.多线程中`i++`安全吗？为什么？
	不安全。因为i++不是原子性操作，该操作分为多个步骤，执行期间任何一步都是有可能被其他线程抢占的。

#### 2.如何线程安全的实现一个计数器？
	可以使用加锁，例如synchronized或者lock。

#### 3.生产者消费者模式
	生产者和消费者在同一时间段内共用同一存储空间，生产者向空间里生产数据，而消费者取走数据。
	优点：支持并发，解耦

#### 4.`Java`有几种线程池？
	①newFixedThreadPool，创建一个指定工作线程数量的线程池。可控制线程最大并发数，超出的线程会在队列中等待。
	②newCachedThreadPool,创建一个可缓存的线程池
	③newSingleThreadExecutor，创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务。
	④newScheduleThreadPool，创建一个定长的线程池，支持定时及周期性任务执行。

#### 5.线程池的好处？
	第一，降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗
	第二，提高响应速度。当任务到达时，任务可以不需要等到线程创建就能执行
	第三，提高线程的可管理性。

#### 6.`sleep()`和`wait()`有什么区别？
	sleep()是线程类（Thread）的方法，导致此线程暂停执行指定时间，把执行机会给其他线程，但是监控状态依然保持，到时后会自动恢复。
调用sleep()不会释放对象锁。
	wait()是`Object`类的方法，对此对象调用wait()方法导致本线程放弃对象锁。

#### 7.`sleep()`和`yield()`有什么区别？
	①sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的机会。`yield()`方法只会给相同优先级或者更高优先级
	线程运行的机会。
	②线程执行sleep()方法后转入阻塞状态，执行yield()方法后转入就绪状态。
	③sleep()方法声明抛出InterruptedException，而yield()方法没有声明任何异常。
	④sleep()比yield()具有更好的可移植性。

#### 8.`synchronized`可重入怎么实现？
	每个锁关联一个线程持有者和一个计数器。当计数器为0时表示该锁没有被任何线程所持有，那么任何线程都可能获得该锁而调用相应方法。
当一个线程请求成功后，JVM会记下持有锁的线程，并将计数器置为1。此时其他线程请求该锁，则必须等待。而该持有锁的线程如果再次请求这个锁，
就可以再次拿到这个锁，同时计数器递增。当线程退出一个synchronized方法/代码块时，计数器会递减，如果计数器为0则释放该锁。

#### 9.什么是死锁？
	两个线程或两个线程以上的线程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是这些线程都陷入了无限的等待中。

#### 10.反射的实现和作用？
	反射就是通过字节码文件找到某一个类、类中的方法及属性等。
	反射的作用：反射机制指的是程序在运行时能够获取自身的信息。
	
#### 11.类加载过程
	①加载
	加载是类加载过程中的一个阶段，这个阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区的这个类的各种数据的入口。
	②连接
		>验证
		该阶段主要目的是为了确保Class文件的字节流中包含的信息是否符合当前虚拟机的要求。
		>准备
		准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。
		>解析
		解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。
	③初始化
	④使用
	⑤卸载
	
